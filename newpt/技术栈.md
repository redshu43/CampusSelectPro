要耐下心子慢慢查找原因，切不可急。
---
### 1. 前后端分离项目,不适用Cookie验证：
传统单体/服务端渲染项目的认证方式（Cookie）
在这种架构下，用户登录，服务器验证通过后，创建一个Session存储在服务端，同时将唯一一个Session ID通过`Set-Cookie`头部发送给浏览器，浏览器会自动在左右同源的请求中带上这个Cookie。

+ 安全隐患：这就产生了 CSRF（跨站请求伪造）攻击。恶意网站可以诱导用户浏览器向目标网站（例如你的银行网站）发起请求，因为浏览器会自动带上 Cookie，服务器会认为这是用户的合法操作。
+ 防御措施：为了防御 CSRF，框架（如 Django, Spring Security）会采用诸如 CSRF Token 的机制。这时，SameSite 属性就成了一个重要的补充防御层。通过将 Cookie 设置为 SameSite=Strict 或 SameSite=Lax，可以限制第三方上下文发起的请求携带 Cookie，从而从浏览器层面遏制 CSRF。

前后端分离项目的认证方式（Token）
用户登录，前端将用户名密码发送给后端API。后端验证通过后，生成一个Token（通常是JWT），并将其返回给前端。这个 Token 包含了用户身份信息和有效期，通常通过响应体返回，而不是Set-Cookie。
前端收到Token后，会将其存储在localStorage,sessionStorage或内存中，在调用任何需要认证的API时，前端需要手动的将这个Token放在HTTP请求的`Authorization`中.

### Spring Security
Spring Security(完整的安保公司)
│
├── SecurityFilterChain (请求处理流程)(安保巡逻队)
│   ├── Filter 1: SecurityContextPersistenceFilter
│   ├── Filter 2: UsernamePasswordAuthenticationFilter  
│   ├── Filter 3: BasicAuthenticationFilter
│   ├── Filter 4: AuthorizationFilter
│   └── Filter n: 自定义过滤器 (如 JWT Filter)
│
├── AuthenticationManager (认证管理器)( 身份验证部门)
│   ├── AuthenticationProvider
│   └── UserDetailsService(员工档案室)
│
├── AccessDecisionManager (访问决策管理器)
│
├── SecurityContext (安全上下文)
│
└── PasswordEncoder (密码编码器)
+++

#####1. HttpSecurity 类：
Spring Security 的核心配置类
包含了所有的安全配置方法
通过它来配置认证、授权、会话管理等
```java
http.csrf(...)          // 配置CSRF
    .cors(...)          // 配置CORS  
    .authorizeHttpRequests(...) // 配置授权
    .sessionManagement(...)     // 配置会话
    .formLogin(...)     // 配置表单登录
    .httpBasic(...)     // 配置HTTP基本认证

```



### JWT
这是一个“数字通行证”。用户使用“用户名/密码”登录，服务器验证成功后，不会把密码返回给用户，而是生成一个加密的，有时效性的字符串返回，这就是JWT
前端拿到这个Token后，必须在之后的所有请求中，都在Header请求头中带上他
后端Spring Security会拦截所有请求，检查Token是否合法，是否过期。

jwt构建
```java
Jwts.builder()           // 创建 JWT 构造器
.claims(claims)          // 设置自定义声明 (Map 或 Claims 对象)
.subject(account)        // 设置主题 (通常是用户名)
.issuedAt(...)           // 设置签发时间
.expiration(...)         // 设置过期时间
.signWith(...)           // 使用密钥签名
.compact()               // 生成最终的 JWT 字符串

```

jwt解析
```java
private Claims extractAllClaims(String token) {
    return Jwts.parser()
            .verifyWith(getSigningKey())  // 设置验证密钥
            .build()                      // 构建解析器
            .parseSignedClaims(token)     // 解析并验证签名
            .getPayload();                // 返回 Claims 部分
}

// 假设 token = "header.payload.signature"

1. Jwts.parser()                    // 创建解析器构造器
2. .verifyWith(getSigningKey())     // 设置签名验证密钥
3. .build()                         // 构建 JwtParser 对象
4. .parseSignedClaims(token)        // 解析并验证 token 签名
   → 验证成功: 返回 Jwt<Header, Claims> 对象
   → 验证失败: 抛出 SignatureException
5. .getPayload()                    // 提取 payload 部分 (Claims)

```

```java
public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token); // final确保安全
        return claimsResolver.apply(claims);
    }

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);  // 接受 T 类型参数，返回 R 类型结果
}



```

### vite正向代理

### nginx反向代理

### 400，500
403： 服务器理解本次请求，但是拒绝访问
500： 服务器错误

### 日志
#### 11.24更新：学生/教师/管理员修改自己的密码


### 传统 DAO 模式 vs MyBatis Mapper 模式
传统方式：

```java
@Repository  // 需要 @Component
public class UserDaoImpl implements UserDao {
@Autowired
private JdbcTemplate jdbcTemplate;

    public User findById(Long id) {
        // 需要自己写 SQL 实现
        String sql = "SELECT * FROM user WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);
    }
}
```
MyBatis Mapper 方式：
```java
@Mapper  // 不是 @Component
public interface UserMapper {
// 只有接口，没有实现类！
User selectById(Long id);
}
```
MyBatis 会自动代理 Mapper 接口生成实现类

这些代理对象由 MyBatis 自己管理，不是 Spring Bean

使用 @Mapper 或 @MapperScan 只是告诉 MyBatis 哪些接口需要被代理

### MaBytis参数
1. **resultType**
指定返回的java类型，MyBatis会自动创建该类型的实例并填充数据，支持基本类型，包装类型，map，自定义实体类
详情见我的xml文件
2. **resultMap**
复杂映射，一般用于驼峰映射解决不了的复杂映射关系
```xml
<!-- 一对一关联 -->
<resultMap id="UserDetailMap" type="com.example.entity.User">
    <id column="id" property="id"/>
    <result column="username" property="username"/>
    <association property="profile" javaType="com.example.entity.UserProfile">
        <result column="profile_id" property="id"/>
        <result column="real_name" property="realName"/>
    </association>
</resultMap>

<select id="getUserWithProfile" resultMap="UserDetailMap">
    SELECT u.id, u.username, up.id as profile_id, up.real_name
    FROM user u LEFT JOIN user_profile up ON u.id = up.user_id
    WHERE u.id = #{id}
</select>
```
3. **parameterType**
参数类型，可以省略，因为MyBatis可以自动判断，支持基本类型，Map，实体类，@Param注解参数
4. **useGeneratedKeys & keyProperty**
主键回填，主键自动增加

无需编写繁琐的映射配置
### 方法参数和返回值在Mapper层的类型选择
方法参数：**Integer**
1. 接受Null,防止NPE
2. 参数校验更安全
3. 业务逻辑更灵活

返回值：**int**
1. 语义明确，影响行数
2. 永远不会返回null
3. 避免不必要的空值检查

### ORM 框架
ORM = Object-Relational Mapping（对象关系映射）

数据库表就像 Excel 表格

Java 对象就像 Word 文档

ORM 框架，自动给双方做转换

**好处**：
减少重复代码 - 不用写大量的 getter/setter
提高开发效率 - 专注业务逻辑，而不是数据访问细节
维护性好 - 数据库结构变化时，只需修改映射配置
避免 SQL 注入 - 使用参数化查询

**使用 AS 后，MyBatis 自动映射" 指的是：**
通过 AS 让数据库列名与 Java 属性名保持一致
MyBatis 利用这个一致性自动完成数据赋值，参数化查询


### @Transactional AOP切面
Spring 会盯着这两个步骤。
ACID 原则中的 A (Atomicity 原子性)：这两个步骤要么一起成功，要么一起失败。
如果第 2 步报错了，数据库会自动 回滚 (Rollback) 第 1 步的操作，把那个 +1 的库存退回去，仿佛什么都没发生过。

事务：靠 **Spring AOP** 代理，在 catch 块里帮你 rollback，保证数据一致性。

想象你要做一个多层蛋糕：

没有 AOP：

```text
第一层：面粉 + 鸡蛋 + 糖 + 烤箱控制
第二层：面粉 + 鸡蛋 + 糖 + 烤箱控制  
第三层：面粉 + 鸡蛋 + 糖 + 烤箱控制
→ 每层都要重复处理烤箱控制，很麻烦！

有 AOP：

第一层：面粉 + 鸡蛋 + 糖
第二层：面粉 + 鸡蛋 + 糖
第三层：面粉 + 鸡蛋 + 糖
⬇️
```
烤箱切面：自动为所有层统一处理烤箱控制

### 数据库行锁 || 乐观锁
当执行 UPDATE、DELETE 或 SELECT ... FOR UPDATE 时
数据库自动为涉及的数据行加锁
事务提交或回滚时自动释放锁，这是最细粒度的锁。


### Redis设计逻辑
**高并发抢课的核心思想： “不能让几千人同时去查数据库里的剩余名额，因为数据库扛不住。
我们要把剩余名额提前存到 Redis 里，让大家去 Redis 里抢**

1. 需要一个接口，系统启动时把所有的课程剩余名额加载到Redis中，改写“学生抢课”的逻辑，让它只查 Redis，不查数据库
```text
以前的逻辑（弱不禁风）： 1000 个请求进来 -> 1000 次查数据库 -> 1000 次行锁争抢 -> 数据库崩溃。

现在的逻辑（坚如磐石）： 1000 个请求进来 -> 先找 Redis 扣库存。

Redis 是内存操作，极快。

前 100 个请求，Redis 扣减成功 -> 放行去连数据库。

后 900 个请求，Redis 返回 -1 (库存不足) -> 直接驳回（根本不给数据库添麻烦）。
```

### Java代码中实现异步的方式
方式一：多线程 (Thread/Runnable) —— 最原始
这是最底层的做法：我自己雇个临时工帮我干活。
```java
public void sendEmail() {
    // 创建一个新的线程去发邮件
    new Thread(() -> {
        System.out.println("开始发邮件..."); 
        // 模拟耗时操作
        Thread.sleep(5000); 
        System.out.println("邮件发送成功！");
    }).start();

    System.out.println("主线程直接返回，不等邮件发送！");
}
```

方式二：Spring 的 @Async 注解 —— 最常用
Spring 封装了线程池，你只需要加个注解，Spring 就会自动把这个方法放到单独的线程里跑。

1. 开启异步支持 (在启动类上)

```Java

@EnableAsync
public class Application {  }
```
2. 使用注解

```Java

@Service
public class EmailService {

    @Async // 加上这个，调用此方法时，主线程直接走人，Spring 会另起线程执行它
    public void sendEmail() {
        // ... 耗时操作 ...
    }
}
```
方式三：CompletableFuture —— 最现代
这是 Java 8 引入的强大工具，支持链式调用和回调（比如：做完A，再做B，如果出错了做C）。
```java
public void doSomething() {
    CompletableFuture.runAsync(() -> {
        // 异步执行的任务
        db.save(data);
    }).thenRun(() -> {
        // 任务完成后执行的回调
        System.out.println("保存完成！");
    });
}
```

🏰 你的系统架构图
👨‍💻 前端 (Vue 3 + Vite)动态路由：根据 Token 角色自动加载菜单。拦截器：Axios 自动携带 JWT Token，统一处理 401/403。交互：Element Plus 美观界面，异步请求反馈。
🛡️ 安全网关 (Spring Security)认证：JWT 无状态认证，双表（Student/Admin）查验。鉴权：RBAC 模型，基于角色的动态拦截 (hasAuthority)。加密：BCrypt 强哈希算法保护密码。
⚡ 高并发防线 (Redis)第一道墙 (防重)：Set 集合实现 $O(1)$ 复杂度的重复选课拦截。第二道墙 (限流)：Atomic Decrement 实现库存预扣减，挡住 99% 的无效流量请求数据库。
+ Spring AMQP
🌊 削峰填谷 (RabbitMQ)异步解耦：将“写库”这一耗时操作从主线程剥离。流量缓冲：无论前端并发多高，通过队列让数据库“细水长流”地处理，防止宕机。
你的 RabbitMQ 消费者 (CourseSelectionListener)
它是异步的：
前端发请求给 Service -> Service 发消息给 MQ -> Service 立刻返回。
Service 根本不等数据库写完，这就是异步。
它也是多线程的：
RabbitMQ 的监听器（Listener）是运行在一个独立的线程里的（不是处理 HTTP 请求的那个主线程）。
所以，你实际上是用 “异步架构 + 多线程处理” 来实现的削峰填谷。

一个毁三观的例子：Node.js vs Java
Node.js：是典型的 “单线程 + 异步”。它只有一个厨师，但他从不等人，所有数据库查询、文件读写全是异步的。所以它能用很少的内存处理极高的并发（只要别让他做复杂的数学计算）。
传统的 Java：是典型的 “多线程 + 同步”（在 BIO 时代）。来一个请求就分配一个厨师，如果请求在查数据库，这个厨师就傻等着。所以 Java 以前很吃内存（现在 Java 也有 NIO 和 虚拟线程了，也变聪明了）。
💾 数据底座 (MySQL)原子更新：利用 SQL 行锁保证最终数据的一致性。事务保障：@Transactional 确保 Redis 回滚与数据库回滚同步。